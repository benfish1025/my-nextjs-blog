---
title: 前端测试入门
excerpt: 应用前端测试可以解决很多工作中的痛点，也是提升个人能力的契机，值得花时间好好研究。那就从积累笔记开始吧！
image: out-in-testing.png
isFeatured: false
date: '2023-10-30'
---

自动化测试能带来很多好处，如以下举例：

1. 可以 **代替手动测试：** Dev时再也不用在页面中左右横条反复走遍各种业务流程了（回归测试），跑通测试也可以减轻项目提测和上线时的心理压力。
2.  **缓解“系统的不可更动性”对开发和优化的束缚：** 有些时候不是我们没有更好的解决方案和优化策略，而是这样的改动往往牵一发而动全身，为了避免引发更大的麻烦只好作罢。

自动化测试是能够彻底改变开发面貌的好东西，为什么这么少人真正在项目中写测试呢？原因有二，一是没时间，二是不会写。照我看，不会写的问题还要更大一些。测试API都是很简单的东西，但是测试组织和测试方法论都比较棘手，大家都嗅到了这里面的“坑”，一想到后续有这么多问题需要面对也就望而却步了。

# 什么是测试？

“测试”是一种软件工程方法，不应直接等同于各种测试库。换言之测试并不一定需要各种各样的库才能完成。《JavaScript忍者秘籍》中为了测试，就使用了作者自己写的断言函数。一个最简单的测试甚至可以通过直接调用函数并判断结果来完成，像下面这个例子：

```jsx
// 测试斐波那契数列取值函数
import { fibonacci } from "../src/math.js";

if (fibonacci(0) !== 0) {
  throw new Error("Invalid 0th fibonacci result");
}
const fib13 = fibonacci(13);
if (fib13 !== 233) {
  throw new Error("Invalid 13th fibonacci result, was=${fib13} wanted=233");
}
```

无论如何，一个测试单元或叫测试用例都是由三个步骤成的：

1. 给出预定值或Mock数据（硬编码的）。
2. 执行操作，例如调用方法。
3. 断言输出值或更新后的状态。

这里我们说到的测试指的是**单元测试**，它专注于测试软件的单一部分，如一个函数。随着测试涉及更多文件和系统，复杂性增加，大家都很自然地根据“测试范围”来对测试命名。除单元测试外，还有组件、视觉和集成测试等，这些术语不是严格定义的，需要根据实际情况的需要来理解。随着了解的深日，我想你会有自己的一套定义和见解。

前端开发最常见的测试分类如下：

- 静态测试：在编写代码逻辑阶段时进行报错提示。(代表库: ESLint、Flow、TypeScript)
- 单元测试： 单元测试的职责是对一些边界情况或者特定的算法进行测试。(代表库: [Jest](https://github.com/facebook/jest)、[Mocha](https://github.com/mochajs/mocha))
- 组件测试：为现代开发框架的基本构成单位——“组件”进行测试。通常验证其输出的DOM结构和行为响应。
- UI测试：一种说法是对DOM一致性进行检测，还有一种说法是建立可供快速查验的组件库（如storybook），更高级的说法是通过在内存中模拟真实渲染结果对项目更改前后进行像素级别的检查。
- 集成测试：模拟用户的行为进行测试，对网络请求、获取数据库的数据等依赖第三方环境的行为进行 Mock。（代表库: [Jest](https://github.com/facebook/jest)、[react-testing-library](https://github.com/testing-library/react-testing-library)、[Vue Testing Library](https://github.com/testing-library/vue-testing-library) 等）
- e2e 测试：模拟用户在真实环境上操作行为（包括网络请求、获取数据库数据等）的测试。（代表库: [Cypress](https://github.com/cypress-io/cypress)）

这里需要注意，集成测试是定义最不清晰和最容易被误解的一种测试类型，关于此点，在下文中会有详细说明。

# 什么时候运行测试？

在现代前端项目中，测试运行的入口通常要通过npm scripts（例如`npm test`），在这个前提下有如下三种运行测试的情形：

- **手动测试调用**：在开发代码库时，手动触发自动化测试（运行`npm test`），通常运行部分测试而不是全部，要实现这一点可以使用Vitest的`command-line filter`和`once`指令。还可以开启watcher，在保存时重新运行测试（这在Vitest中是默认开启的）。
- **提交或PR前运行测试**：代码需要在合并回主分支时是否正常运行。例如，GitHub通过GitHub Actions的“状态检查”来实现这一点。
- **持续集成中的测试运行**：一旦PR被接受，大多数代码库会再次基于主分支运行测试。这些结果通常显示在持续集成（CI）仪表板上，显示整个项目的健康状况。

# 测试在什么环境中运行？

测试越复杂，环境就越重要。对于不使用 DOM 功能或只使用极少功能（即使是在 Node.js 和类似运行时中可用的功能（如 `fetch` 或 `EventTarget`）中的功能）的测试，环境无关紧要。但是大型项目确是必须的。测试运行环境可以简单分为：

- Node.js环境：是测试运行的基础环境，但不包括浏览器API，如DOM和HTML元素操作。
- 浏览器环境：很多端到端测试框架都是在浏览器窗口中运行的。
- 模拟的浏览器环境：如很多测试框架都是用的JSDOM库，它完整实现了DOM节点类型及其继承关系，可以在内存中进行DOM操作。他还是先了很多浏览器环境中的API，

环境使用的原则：

- 将业务逻辑与渲染或特定于Node的代码分离，可以使代码更易于测试。
- 模拟的浏览器环境（JSDOM）适用于小型组件测试。
- 对于大型测试（例如可以模拟用户登录并执行核心操作的端到端测试），可以完全在真实浏览器中运行。

# 不同种类的测试如何选择？

# 写多少测试？

写多少测试合适，跟测试覆盖率有关。**测试覆盖率**(test coverage)是衡量软件测试**完整性**的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。

最著名的测试覆盖率就是代码覆盖率，**被执行的代码数量与代码总数量之间的比值，就叫做代码覆盖率**。关于测试覆盖率需要思考以下几个概念：

- 行覆盖率（line coverage）：是否每一行都执行了？
- 函数覆盖率（function coverage）：是否每个函数都调用了？
- 分支覆盖率（branch coverage）：是否每个if代码块都执行了？
- 语句覆盖率（statement coverage）：是否每个语句都执行了？

要避免为了测试而测试，片面追求测试覆盖率的做法。没有覆盖率数据，测试工作会有点像在“黑灯瞎火”中走路。有了覆盖率数据，并持续监测，利用和改进这个数据，才是一条让测试工作越来越好的光明大道。100%测试覆盖率反而反应了项目代码的健康状况不良，关注点错置。

# 如何做需求分析？

用描述性自然语言定义的测试，客户、测试人员和开发人员都能看得懂，能达成共识，这种语法叫做 Gherkin Syntax，小黄瓜语法。

- 以关键字 Scenario、Feature 等来描述场景
- 以关键字 Given、When、Then 来描述步骤

```
Feature: 添加任务

  Scenario: 在输入框中输入任务名敲回车确定，输出到任务列表中
    Given "Hello World"
    When 在输入框中敲回车
    Then 任务列表增加一个名称为 "Hello World" 的任务

  Scenario: 在输入框中输入空内容，不输出到任务列表中
    Given ""
    When 在输入框中敲回车
    Then 任务列表中不增加任何内容

```

Cucumber 读取使用 Gherkin 语法描述的纯文本形式的可执行规范，并验证该软件是否满足那些规范所说的内容。规范包含多个示例或方案。

每个方案都是 Cucumber 要执行的步骤的列表。 Cucumber 验证软件是否符合规范，并生成一个报告，指出每种情况的成功或失败。

