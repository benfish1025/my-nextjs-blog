---
title: 'React：问题与解答'
date: '2022-11-16'
image: react.png
excerpt: 网上同质性的题目和解答很多，但是都不合口味。这里总结一下自己觉得有兴趣的问题，并给出解答，权作为参考。
isFeatured: true
---

# 组件和元素有什么区别？

组件就是创建元素的工厂，而元素是虚拟DOM中的一组描述，他描述了某个HTML标签的构成特征。

# 状态更新批处理的设计意图？批处理是否会引发错误？

React通过内置的Hooks以及事件处理程序中的组件更新来优化应用程序性能，从而防止组件在每次状态更新时重新渲染。这个优化过程称为批处理。在React版本17中，这种批处理仅限于浏览器事件。但在React版本18中，引入了批处理的改进版本，称为自动批处理。

自动批处理支持从任何位置调用状态更新，而不仅仅是在浏览器事件中。换句话说，它支持原生事件处理程序、异步操作、超时和间隔。这意味着在React版本18中，无论是在哪个上下文中调用状态更新，React都能够有效地将多个更新批量处理，从而提高应用程序的性能。

从ReactDOM引入了flushSync API函数可以终止批处理，但是不推荐这样做。

一般情况下，React会在下一个事件发生之前完成所有待完成的状态更新（也就是“最后一次批处理”），因此不存在陈旧数据的风险。但是，如果你在事件出来函数内部使用 `setCounter(a + 1)` 这样的形式连续进行多次状态更新，会导致错误。因为 `setCounter(a + 1)` 并不会引用到最新的状态值，而是引用到了点击事件处理函数被创建时的状态值，这样会导致连续多次的状态更新都是基于同一个旧值进行的，而不是依次基于更新后的值。这会导致你的状态变化不如预期，结果可能是不正确的。

正确的做法是使用函数形式的更新器，例如：

```jsx
function handleClick() {
    setCounter(prevCounter => prevCounter + 1);
    setCounter(prevCounter => prevCounter + 1);
    setCounter(prevCounter => prevCounter + 1);
}
//除以上情况外，使用updater函数更新状态的方法是可选的，并不是必须的
```

# 如何理解合成事件的设计意图？

在React中，合成事件是对浏览器实际本机事件对象的跨浏览器包装。它提供了一个统一的API，防止浏览器之间的不一致性，并确保事件在多个平台上都能正常工作。

合成事件还保持了逻辑一致性，比如通过createPortal出逃节点中的事件冒泡遵循React树而不是DOM树。

# 虚拟DOM是如何工作的？

虚拟DOM的主要目的是尽量减少在重新呈现UI时进行DOM操作的数量。React和Vue.js技术在底层都使用虚拟DOM来增强性能，并将手动DOM操作从开发人员手中抽象出来。这种编程机制的工作分为四个主要步骤。

1. 当应用程序第一次呈现时，React或Vue.js会创建一个虚拟DOM来表示UI，并将其存储在内存中。这个虚拟DOM代表了UI的初始状态。
2. 当底层状态发生变化时，React或Vue.js会自动为更新创建一个新的虚拟DOM。由于虚拟DOM只是一个表示UI的对象，因此在这个阶段UI中不会发生任何实际的更改或重新绘制。
3. 一旦创建了新的虚拟DOM，React或Vue.js就会将其与之前的虚拟DOM或快照进行比较。它们使用差分算法来比较这些变化，这个过程被称为调和（reconciliation）。
4. 在调和过程之后，React或Vue.js使用一个渲染引擎（如ReactDOM或Vue的渲染引擎）来接受虚拟DOM中的更改并将其反映到真实的DOM中，从而更新用户界面。

# 如何理解Fiber的设计意图？Fiber的工作过程是怎样的？

Fiber是React版本16中引入的一个新的协调引擎，它支持内置调度和虚拟DOM的增量渲染。增量渲染意味着能够将渲染工作分割成块，并将其分散到多个帧上。因此，在增量渲染的帮助下，Fiber在动画、布局和手势等领域提高了应用程序的性能。

这个新的解析器完全重写了一种叫做“栈和解器”的旧的解析算法。Fiber的引入使得React能够更灵活地管理和调度组件更新，从而提高了应用程序的性能和响应性。

# 如何理解单向数据流和双向数据流？

从前端的角度简单来说，“单向数据流”描述的是数据的读写关系。我们只要找到系统中的读写行为，抽象出具体的几个模块，把读写关系表示出来后就能看出系统是单向数据流向的还是双向的。写行为必须是具体的，比如我们仍然可以通过dispatch的方式修改数据，但是写行为并不出现在时间处理函数中，而是出现在Reducer函数中，在抽象层面上，他们分属于不同的区域。指的就是数据与DOM之间的映射关系。“单向数据流”的说法至少可以在两个场景中出现：

- 描述函数式编程中父函数与子函数之间的关系；
- 描述抽象层面上的数据层与视图层的关系，不单单指前端的交互界面开发，在后端开发中也会有单向数据流的问题；

理解单向数据流可以先举一个双向数据流的例子，最典型的是DreamWeaver编辑器，它可以直接在界面上修改元素同时反应到源代码上。我们都知道这在常规的数据驱动框架中是不可能发生的。DOM的变化不会影响到数据，DOM只能作为数据流的结果绝不可能作为来源，数据与视图之间是严格单向的。

单向数据流之所以让人困惑，是因为在交互界面开发中还存在事件机制，在单向数据流的规定下，起到了修改数据的作用，比如React的回调函数和Vue的事件触发器。混乱的事件仍然可能导致混乱的数据流向，Flux架构在单向数据流基础上，设计了Dispatcher进一步对事件处理进行约束，将它们处理数据的入口接管了，从而达到使数据流清洗的目的。所以在这个意义上，Vue表单中的“数据双向绑定”只是事件机制的语法糖。

另一种对单向数据流的补充是React和Vue中都有的refs，它可以在典型的单向数据流之外命令式地修改DOM。

# Hooks的设计意图？

可以说在之所以设计Hooks就是为了不写类和生命周期函数，再说得高级一点就是将范式转移成函数式的。具体来说解决的类组件痛点有以下几个：

- 在类组件之间重用状态逻辑有困难，renderProps和HOC模式比较繁琐。
- 复杂组件的代码组织造成理解上的困难。
- 在类组件中进行事件绑定还要处理this问题。

# 在使用Hooks时要遵循两个主要规则:

1. 只在顶层调用Hooks：不应在循环、条件或嵌套函数中调用Hooks，也不应该在一些提前的return语句后面使用。Hooks的调用顺序必须是确定的，不应该在组件的内部逻辑语句中调用钩子以使数据发生混乱。
2. 只从React函数中调用钩子：不应该从普通的JavaScript函数中调用钩子。

使用eslint插件eslint-plugin-react-hooks可以有效检查。

# 什么时候使用useReducer而不是useState？

使用useReducer有两个明显的好处：

1. 避免setState函数及其数据处理逻辑的满天飞。
2. 处理相互依赖的状态的更新时，不需要连续setState，或使用useMemo进行复杂的动作抽象。

# 什么方法可以实现两个组件消费同一个store但是取到的值不同？

有时候，你可能需要在组件树的特定部分覆盖上下文的值。为了实现这一点，你可以将该部分组件包装在一个新的上下文提供程序中，并为其提供不同的值。

举例来说，下面的代码会在除了联系人页面之外的所有页面中应用蓝色背景，而联系人页面则使用白色背景：

```jsx
<ColorContext.Provider value="blue">
  <About />
  <Services />
  <Clients />
  <ColorContext.Provider value="white">
    <Contact />
  </ColorContext.Provider>
</ColorContext.Provider>

```

这段代码通过两个不同的 `<ColorContext.Provider>` 包裹了组件。第一个提供了蓝色背景，包含了除了联系人页面之外的所有组件，而第二个提供了白色背景，只包含了联系人页面。这样就能实现在组件树中的不同部分应用不同的上下文值。你可以任意嵌套使用上下文提供程序，没有限制。

# 如何衡量组件的健康程度？

组件的大小当然也是一个指标，但是大组件根据情况有时是不可避免的。我提出一个指标，就是useEffect的数量，组件可以大这没问题，但是一定要控制useEffect的数量。

# 如何设置errorBoundary？如何调试它？它会在什么时候起作用？

可以通过使用React DevTools(红色按钮)强制所选组件进入错误状态来验证错误边界。

可以不必自己书写，**[react-error-boundary](https://github.com/bvaughn/react-error-boundary)库是很好的选择。**

errorBoundary会捕获所有渲染阶段的错误，而这种错误大部分是由空值导致的referenceError，应通过使用可选链、检查mapStore等方式尽量避免。

非渲染阶段的错误包括事件处理函数中的错误、异步代码中的错误。这种错误不会被errorBoundary捕获。

# 如何分析某个组件的渲染性能？

React提供了两种不同的方法来测量应用程序的渲染性能：React Profiler 组件和React DevTools Profiler 选项卡。使用Profiler 选项卡不需要编写代码，可以通过点选在空间和时间两个温维度上查看渲染耗时和原因。但是Profiler 选项卡不支持含有Suspense特性的组件。

# 什么是React严格模式？如何启用？

React严格模式是React提供的内部组件，将它包绕在跟组建或任意层级组件外，便可以获得更加丰富的报错信息，包括useEffect中没有提供注销函数等错误。使用严格模式后，其内部的组件和Effect可能会根据检查需要多运行一次用来检查函数纯不纯或发现其他错误，所以该模式只会在开发状态时起作用。

# 什么是Redux-Chunk、Redux-Sage、RTK、RTK Query？

Redux-Chunk、Redux-Sage用来处理异步逻辑，前者使用中间件模式，后者使用生成器。

RTK是一个帮助Redux减少样板代码的工具库。RTK Query是RTK工具包中的一个工具，用于请求数据和共享缓存。

# SSR优点很多但有没有什么缺点？

服务器负载会增加需要更昂贵的服务器基础设施；代码逻辑要更复杂；可能会丧失利用用户客户端缓存的优势。

# Hooks有没有什么缺点？

Hooks引出了CustomerHooks的代码组织模式。但是CustomerHooks会将使用usedState、useReducer声明的状态遮蔽掉，从而让人忽略re-render引起的性能问题。useXXX在代码中看似很优雅，但是CustomerHooks却并不可以随处使用，它至少不可以用在比较顶层的组件中，最好只在颗粒化的小组件中使用。因为CustomerHooks中往往——因为内部封装我们只能用“往往”——含有State会引起整棵子树的re-render。
